
# generated by Gemini ai from 'Prompted Can you write a game of Pool to play in Pythonista'
# document the changes CMT May2025
# 1. Define font for lines in measure_string and draw_string
# change dt to 0.2 in function update
# changed colours
# changed random positioning by shuffling inly the locations leaving id and colour alone
import ui
import math
import random

# --- Constants ---
TABLE_WIDTH = 1200
TABLE_HEIGHT = 600
BALL_RADIUS = 20
POCKET_RADIUS = BALL_RADIUS * 1.8 # Pockets are larger than balls
FONT = 'Arial'
OFFSET = 50
# Ball colors (example for 8-ball)
BALL_COLORS = {
    0: 'white',   # Cue Ball
    1: 'yellow',
    2: 'blue',
    3: 'red',
    4: 'purple',
    5: 'orange',
    6: 'darkgreen',
    7: 'maroon',
    8: 'black',   # 8-ball
    9: 'lightyellow',  # Solid (example)
    10: 'lightblue',   # Striped (example)
    11: 'lightpink',
    12: 'mediumpurple',
    13: 'sandybrown',
    14: 'lightgreen',
    15: 'maroon'
    # ... and so on for all 15 balls
}

def add(a, b):
    """ helper function to add 2 tuples """
    return tuple(p + q for p, q in zip(a, b))
    
# --- Ball Class ---
class Ball:
    def __init__(self, x, y, ball_id):
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.radius = BALL_RADIUS
        self.color = BALL_COLORS.get(ball_id, 'gray') # Default if not found
        self.ball_id = ball_id
        self.in_pocket = False
        self.image = ui.Image.named('pzl:BallBlue').with_rendering_mode(ui.RENDERING_MODE_TEMPLATE)

    def move(self, dt):
        if not self.in_pocket:
            self.x += self.vx * dt
            self.y += self.vy * dt
            # Apply friction (simple damping)
            self.vx *= 0.991
            self.vy *= 0.991
            # Stop if velocity is very low
            if abs(self.vx) < 0.1 and abs(self.vy) < 0.1:
                self.vx = 0
                self.vy = 0

    def draw(self):
        
        if not self.in_pocket:
            path = ui.Path.oval(self.x - self.radius, self.y - self.radius,
                                self.radius * 2, self.radius * 2)
            ui.set_color(self.color)
            path.fill()
            #self.image.tintcolor=self.color
            #self.image.draw(self.x, self.y, BALL_RADIUS*2, BALL_RADIUS*2)
            #ui.set_color(self.color)
            # Draw ball number (optional)
            if self.ball_id > 0: # Don't draw number for cue ball
                ui.set_color('white' if self.color != 'black' else 'black')
                font_size = self.radius * 0.8
                text_width, text_height = ui.measure_string(str(self.ball_id), font=(FONT, font_size))
                ui.draw_string(str(self.ball_id),
                               (self.x  - text_width / 2, self.y - text_height / 2,text_width, text_height),
                               font=(FONT, font_size))
                print(self.ball_id)


# --- PoolTable View ---
class PoolTable(ui.View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.background_color = '#00c000' # Dark green felt
        self.balls = []
        self.pockets = []
        self.cue_ball = None
        self.setup_table()
        self.shot_power = 0 # 0-100
        self.aim_angle = 0 # Radians
        self.is_aiming = False
        self.shot_in_progress = False

    def setup_table(self):
        # Initialize pockets (simplified corner and side pockets)
        self.pockets.append((0, 0)) # Top-left
        self.pockets.append((TABLE_WIDTH / 2, 0)) # Top-middle
        self.pockets.append((TABLE_WIDTH, 0)) # Top-right
        self.pockets.append((0, TABLE_HEIGHT)) # Bottom-left
        self.pockets.append((TABLE_WIDTH / 2, TABLE_HEIGHT)) # Bottom-middle
        self.pockets.append((TABLE_WIDTH, TABLE_HEIGHT)) # Bottom-right
        
        self.pockets =[add(pocket, (OFFSET, OFFSET)) for pocket in self.pockets]

        # Initialize balls (simplified 8-ball rack + cue ball)
        # Cue ball
        self.cue_ball = Ball(TABLE_WIDTH / 4, TABLE_HEIGHT / 2, 0)
        self.balls.append(self.cue_ball)

        # Rack (example of a simple triangle)
        # This is a very basic placement and would need refinement for real 8-ball
        start_x = TABLE_WIDTH * 0.75
        start_y = TABLE_HEIGHT / 2
        row_gap = BALL_RADIUS * 2 * 1.1 # Small gap between balls
        ball_id_counter = 1
        for row in range(5):
            for col in range(row + 1):
                if ball_id_counter <= 15: # Assuming 15 object balls + cue ball
                    x = start_x + row * row_gap * math.sqrt(3) / 2
                    y = start_y + col * row_gap - row * row_gap / 2
                    if ball_id_counter == 8: # Place 8-ball in the center of the third row
                        self.balls.append(Ball(x, y, 8))
                    else:
                        self.balls.append(Ball(x, y, ball_id_counter))
                    ball_id_counter += 1
        # Shuffle non-8-ball object balls for more realistic setup
        non_8_balls = [b for b in self.balls if b.ball_id not in (0, 8)]
        locs = [(b.x, b.y) for b in non_8_balls]
        random.shuffle(locs)
        for i, b in enumerate(non_8_balls):
            b.x = locs[i][0]
            b.y= locs[i][1]
        for b in self.balls:
          b.x += OFFSET
          b.y += OFFSET
        

    def draw(self):
        
        # Draw pockets
        for px, py in self.pockets:
            path = ui.Path.oval(px - POCKET_RADIUS/2, py - POCKET_RADIUS/2,
                              POCKET_RADIUS * 2, POCKET_RADIUS * 2)                 
            ui.set_color('black')
            path.fill()
        # draw frame
        outside = ui.Path.rounded_rect(OFFSET, OFFSET,  TABLE_WIDTH+POCKET_RADIUS*1.2, TABLE_HEIGHT+POCKET_RADIUS*1.2, POCKET_RADIUS*0.5)
        outside.line_width = POCKET_RADIUS
        ui.set_color('brown')
        outside.stroke()
        #
        # Draw balls
        print('drawing')
        for ball in self.balls:
            ball.draw()

        # Draw cue stick/aim line if aiming
        if self.is_aiming and self.cue_ball:
            ui.set_color((0.8, 0.8, 0.8, 0.5)) # Semi-transparent grey
            path = ui.Path()
            line_length = 150 # Length of the aiming line
            end_x = self.cue_ball.x + line_length * math.cos(self.aim_angle)
            end_y = self.cue_ball.y + line_length * math.sin(self.aim_angle)
            path.move_to(self.cue_ball.x, self.cue_ball.y)
            path.line_to(end_x, end_y)
            path.line_width = 3
            path.stroke()

            # Draw power indicator (simple line)
            ui.set_color('red')
            power_line_length = self.shot_power * 1.5 # Scale power to line length
            power_x = self.cue_ball.x - power_line_length * math.cos(self.aim_angle)
            power_y = self.cue_ball.y - power_line_length * math.sin(self.aim_angle)
            path = ui.Path()
            path.move_to(self.cue_ball.x, self.cue_ball.y)
            path.line_to(power_x, power_y)
            path.line_width = 5
            path.stroke()


    def update(self):
        dt = 0.2 # Time step for physics
        if self.shot_in_progress:
            # Move balls
            for ball in self.balls:
                ball.move(dt)

            # Collision detection and response
            self.handle_collisions()
            self.handle_pocketing()

            # Check if all balls have stopped
            all_stopped = all(b.vx == 0 and b.vy == 0 for b in self.balls)
            if all_stopped:
                self.shot_in_progress = False
                print("Shot ended.")
                # TODO: Implement turn-based logic, fouls, etc.

        self.set_needs_display() # Redraw the view

    def touch_began(self, touch):
        if not self.shot_in_progress:
            if self.cue_ball:
                dist = math.hypot(touch.location.x - self.cue_ball.x,
                                  touch.location.y - self.cue_ball.y)
                if dist < BALL_RADIUS * 2: # Tapped near cue ball to start aiming
                    self.is_aiming = True
                    self.aim_angle = math.atan2(touch.location.y - self.cue_ball.y,
                                                touch.location.x - self.cue_ball.x)
                    self.shot_power = 0
                    print("Aiming started.")

    def touch_moved(self, touch):
        if self.is_aiming and self.cue_ball:
            # Adjust aim angle
            self.aim_angle = math.atan2(touch.location.y - self.cue_ball.y,
                                        touch.location.x - self.cue_ball.x)

            # Adjust power based on distance from cue ball
            dist = math.hypot(touch.location.x - self.cue_ball.x,
                              touch.location.y - self.cue_ball.y)
            self.shot_power = min(100, max(0, dist * 0.5)) # Scale and clamp
            # print(f"Aim: {math.degrees(self.aim_angle):.1f} deg, Power: {self.shot_power:.1f}")

    def touch_ended(self, touch):
        if self.is_aiming and not self.shot_in_progress:
            self.is_aiming = False
            self.shot_in_progress = True
            print(f"Shot fired! Power: {self.shot_power:.1f}")
            # Apply initial velocity to cue ball
            force = self.shot_power * 0.5 # Adjust this factor for desired speed
            self.cue_ball.vx = force * math.cos(self.aim_angle)
            self.cue_ball.vy = force * math.sin(self.aim_angle)
            # Reverse direction for a more intuitive "pull back" feel
            self.cue_ball.vx *= -1
            self.cue_ball.vy *= -1

    def handle_collisions(self):
        # Ball-to-ball collisions
        for i, ball1 in enumerate(self.balls):
            if ball1.in_pocket: continue
            for j, ball2 in enumerate(self.balls):
                if i >= j or ball2.in_pocket: continue # Avoid self-collision and double-checking

                dx = ball2.x - ball1.x
                dy = ball2.y - ball1.y
                distance = math.hypot(dx, dy)

                if distance < ball1.radius + ball2.radius:
                    # Balls are overlapping, resolve overlap
                    overlap = (ball1.radius + ball2.radius) - distance
                    # Move balls apart
                    if distance != 0: # Avoid division by zero
                        nx = dx / distance # Normal x
                        ny = dy / distance # Normal y
                        ball1.x -= nx * overlap / 2
                        ball1.y -= ny * overlap / 2
                        ball2.x += nx * overlap / 2
                        ball2.y += ny * overlap / 2

                    # Elastic collision (simplified)
                    # Get unit normal and tangent vectors
                    if distance == 0: continue # Should not happen after overlap resolution, but for safety
                    nx = dx / distance
                    ny = dy / distance
                    tx = -ny
                    ty = nx

                    # Project velocities onto normal and tangent axes
                    v1n = ball1.vx * nx + ball1.vy * ny
                    v1t = ball1.vx * tx + ball1.vy * ty
                    v2n = ball2.vx * nx + ball2.vy * ny
                    v2t = ball2.vx * tx + ball2.vy * ty

                    # For elastic collision, swap normal velocities
                    # (assuming equal mass for simplicity, which is true for pool balls)
                    # If masses were different, use conservation of momentum equations
                    new_v1n = v2n
                    new_v2n = v1n

                    # Convert scalar normal and tangent velocities back to vector components
                    ball1.vx = new_v1n * nx + v1t * tx
                    ball1.vy = new_v1n * ny + v1t * ty
                    ball2.vx = new_v2n * nx + v2t * tx
                    ball2.vy = new_v2n * ny + v2t * ty

        # Ball-to-cushion collisions (simplified AABB table)
        for ball in self.balls:
            if ball.in_pocket: continue
            # Left wall
            if ball.x - ball.radius < OFFSET:
                ball.x = ball.radius + OFFSET
                ball.vx *= -1 * 0.8 # Bounce with some energy loss
            # Right wall
            if ball.x + ball.radius > TABLE_WIDTH + OFFSET:
                ball.x = TABLE_WIDTH - ball.radius + OFFSET
                ball.vx *= -1 * 0.8
            # Top wall
            if ball.y - ball.radius < OFFSET:
                ball.y = ball.radius + OFFSET
                ball.vy *= -1 * 0.8
            # Bottom wall
            if ball.y + ball.radius > TABLE_HEIGHT + OFFSET:
                ball.y = TABLE_HEIGHT - ball.radius + OFFSET
                ball.vy *= -1 * 0.8

    def handle_pocketing(self):
        for ball in self.balls[:]:
            if ball.in_pocket: continue
            for px, py in self.pockets:
                dist_to_pocket = math.hypot(ball.x - px, ball.y - py)
                if dist_to_pocket < POCKET_RADIUS:
                    ball.in_pocket = True
                    ball.vx = 0
                    ball.vy = 0
                    print(f"Ball {ball.ball_id} pocketed!")
                    if ball.ball_id == 0: # Cue ball pocketed (foul in most rules)
                        print("Cue ball pocketed! Foul!")
                        # TODO: Handle foul: place cue ball back, next player's turn etc.
                        # For now, just remove it.
                        ball.x = OFFSET + TABLE_WIDTH / 4
                        ball.y = OFFSET + TABLE_HEIGHT / 2
                        ball.in_pocket = False
                        # self.balls.remove(ball) # Or just mark as in_pocket
                    elif ball.ball_id == 8:
                        # TODO: Game over logic for 8-ball
                        print("8-ball pocketed!")
                    else:
                        pass
                        #ball = None


# --- Game Setup ---
def main():
    v = PoolTable(frame=(0, 0, TABLE_WIDTH, TABLE_HEIGHT))
    v.name = "Pythonista Pool"
    v.present('full_screen') # Use 'sheet' for a simple popup window
    v.update_interval = 1/60.0 # Call update 60 times per second

if __name__ == '__main__':
    main()
