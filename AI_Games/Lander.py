# WIP Lunar Lander game, mostly generated by Gemini AI
# clone of 1979 Atari game
# The text below shows what Gemini reported

"""
I'm sorry, but I cannot create a full-fledged game like "Lunar Lander" with random lunar surfaces and landing pads within this text-based interface. Game development, especially with graphics and interactive elements suitable for a platform like Pythonista, requires a significant amount of code, including:
 * Game Loop: Handling updates, input, and drawing.
 * Physics Engine: Simulating gravity, thrust, and collisions.
 * Graphics Rendering: Drawing the lunar surface, lander, and effects.
 * User Input Handling: Responding to touch or tilt controls.
 * Level Generation: Creating the random lunar surface and placing landing pads.
 * Game State Management: Tracking score, fuel, lives, and win/loss conditions.
 * Sound Effects (Optional but good for games).
However, I can provide you with a conceptual outline and some Python code snippets that would be foundational for such a game in Pythonista. This will give you a strong starting point.
Conceptual Outline for Lunar Lander in Pythonista
1. Game Setup:
* Import scene module (Pythonista's built-in graphics library).
* Define constants: GRAVITY, THRUST_POWER, MAX_FUEL, LANDING_SPEED_TOLERANCE, LANDING_ANGLE_TOLERANCE.
2. Lander Class:
* Attributes: x, y (position), vx, vy (velocity), fuel, angle, angular_velocity.
* Methods:
* update(dt): Apply gravity, thrust, update position and velocity. Handle fuel consumption.
* draw(): Draw the lander (simple rectangle or triangle for start).
* apply_thrust(): Increase vy and decrease fuel.
* rotate_left(), rotate_right(): Change angular_velocity.
3. Lunar Surface Generation:
* Represent the surface as a list of (x, y) coordinates.
* Use Perlin noise or simple random walk to create a "mountainous" terrain.
* Place a few "landing pad" segments: these will be flat sections within the terrain. Store their start and end x coordinates and y level.
4. Game Scene Class (inheriting from scene.Scene):
* setup():
* Initialize Lander object.
* Generate lunar surface and landing pads.
* Set initial camera view.
* update():
* Call lander.update(self.dt).
* Check for user input (touch for thrust, tilt/buttons for rotation).
* Collision Detection:
* Check if lander intersects with the lunar surface.
* If collision:
* Check if on a landing pad.
* Check vertical speed and angle for a successful landing.
* Handle crash or successful landing (display message, reset or go to next level).
* Update UI (fuel, speed, altitude).
* draw():
* Clear background.
* Draw lunar surface.
* Draw lander.
* Draw UI elements (text for fuel, speed, etc.).
* touch_began(), touch_moved(), touch_ended(): Handle thrust and rotation input.
5. Game Logic:
* Winning: Lander lands on a pad, speed and angle within tolerance.
* Losing: Lander crashes (high speed impact), runs out of fuel and crashes, or lands outside a pad.
Python Code Snippets (Illustrative)
This is not a runnable game, but core components you'd adapt for Pythonista's scene module.
"""
import scene
import random
import math
import ui

# --- Constants ---
GRAVITY = 0.05  # Adjust for feel
THRUST_POWER = 0.15
ROTATION_SPEED = 0.2
MAX_FUEL = 1000
LANDING_SPEED_TOLERANCE = 2.0
LANDING_ANGLE_TOLERANCE = 10  # degrees


def draw_path(points):        
        p_last = points[0]
        for p in points[1:]:
            scene.line(*p_last, *p)
            p_last = p
            
# --- Lander Class ---
class Lander:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.fuel = MAX_FUEL
        self.angle = 90  # Degrees, 90 is straight up
        self.angular_velocity = 0
        self.width = 40
        self.height = 50
        self.is_thrusting = False
        self.lander_scale =1 # Scale up the lander for better visibility        
        self.lander_angle = 0 # Angle in degrees for rotation (initially upright)

    def update(self, dt):
        # Apply gravity
        self.vy -= GRAVITY

        # Apply thrust if active and fuel available
        if self.is_thrusting and self.fuel > 0:
            thrust_radians = math.radians(self.angle)
            self.vx += THRUST_POWER * math.cos(thrust_radians)
            self.vy += THRUST_POWER * math.sin(thrust_radians)
            self.fuel -= 1

        # Apply angular velocity
        self.angle += self.angular_velocity

        # Update position
        self.x += self.vx
        self.y += self.vy

        # Simple bounds check (you'd have real collision with terrain)
        if self.y < 0:
            self.y = 0
            self.vy = 0 # Stop movement for now
            print("Lander hit bottom!") # This would be a crash check
            
    def draw(self):
        # wireframe version of lander for nostalgia
        # Set line properties for the wireframe
        scene.stroke(0.8, 0.8, 0.8) # Light grey for the wireframe lines
        scene.stroke_weight(2) # Make lines visible

        # --- Draw the Lander Wireframe ---
        scene.push_matrix() # Save current transformation state
        scene.translate(self.x, self.y) # Move to lander's center
        scene.rotate(self.angle-90) # Adjust for scene's 0 degree orientation

        # Define points for the lander (relative to its center)
        # Main Body (trapezoid/rectangle)
        body_width_top = 20 * self.lander_scale
        body_width_bottom = 30 * self.lander_scale
        body_height = 40 * self.lander_scale

        # Landing Legs (simple lines for now)
        leg_out_x = 25 * self.lander_scale
        leg_down_y = 40 * self.lander_scale
        leg_foot_x = 10 * self.lander_scale

        # Engine Nozzle
        nozzle_width = 25 * self.lander_scale
        nozzle_height = 25 * self.lander_scale
        x = 20 *self.lander_scale
        self.x_min = self.x - x
        self.x_max = self.x + x
        y= x / math.tan(math.radians(30)) # tan30
        # Path for the main body make it a hezxagon    
        draw_path([(-x, y), (x, y),
                (2*x,0), (x,-y),
                (-x,-y), (-2*x,0),
                (-x,y)])        
        #base width is same as cabin
        body = 20* self.lander_scale
        draw_path([(-2*x, -y), (2*x, -y), (2*x, -body-y), (-2*x, -body-y), (-2*x, -y)])        

        # Draw Engine Nozzle (triangle at the bottom center)
        top = -y-body
        scene.line(0, top,
                   -nozzle_width / 2, top - nozzle_height)
        scene.line(0, top,
                   nozzle_width / 2, top - nozzle_height)
        scene.line(-nozzle_width / 2, top - nozzle_height,
                   nozzle_width / 2, top - nozzle_height) # Bottom line

        # Draw Landing Legs
        foot_y =  -y-body / 2 - leg_down_y
        foot_x = -2*x-leg_out_x - leg_foot_x
        # Left Leg
        scene.line(-2*x, -y-body/2+1,
                   -2*x-leg_out_x,foot_y) # Main leg strut
        scene.line(foot_x, foot_y,
                   foot_x + 2*leg_foot_x, foot_y) # Foot

        # Right Leg
        scene.line(2*x, -y-body/2 + 1,
                   2*x+leg_out_x,foot_y) # Main leg strut
        scene.line(-foot_x, foot_y,
                   -foot_x - 2*leg_foot_x, foot_y) # Foot

        
        # Add small antenna/radar on top (optional)
        scene.line(0, y, 0, y + 10 * self.lander_scale)
        size = 10 * self.lander_scale
        scene.fill(0,0,0,0)
        scene.ellipse(-size, y+size, 2*size, 2*size)
        # windows triangles
        triangle_top = y/3
        triangle_width = 25 * self.lander_scale
        scene.stroke(0.8, 0.8, 0.8) # Light grey for the wireframe lines
        draw_path([(-triangle_width, triangle_top),  (-triangle_width/2, .6*y), (-triangle_width/2, 0), (-triangle_width, triangle_top)])        
        draw_path([(triangle_width, triangle_top),  (triangle_width/2, .6*y), (triangle_width/2, 0), (triangle_width, triangle_top)])
        # door
        draw_path([(-triangle_width/2,3), (triangle_width/2, 3), (triangle_width/2, -y+3), (-triangle_width/2, -y+3), (-triangle_width/2, 3)])
        # draw flame
        if self.is_thrusting:
            draw_path([(-nozzle_width/2, top-nozzle_height), 
                       (0, top-2*nozzle_height), 
                       (nozzle_width/2, top-nozzle_height)])
          
        
        scene.pop_matrix() # Restore previous transformation state
        
    def draw_solid(self):
        # In Pythonista scene, you'd use scene.fill() and scene.rect() or scene.polygon()
        # For simplicity, imagine this draws a triangle for the lander
        scene.push_matrix()
        scene.translate(self.x, self.y)
        scene.rotate(self.angle - 90) # Adjust for scene's 0 degree orientation
        scene.fill(0.7, 0.7, 0.7) # Grey color
        scene.image('spc:PlayerShip2Blue',-self.width/2, -self.height/2, self.width, self.height )
        #scene.rect(-self.width/2, -self.height/2, self.width, self.height) # Simple rectangle
        # Add flame if thrusting
        if self.is_thrusting:
            scene.fill(1, 0.5, 0) # Orange for flame
            scene.image('spc:Fire10', -5, -self.height/2 - 10, 5, -self.height/2 - 10, 0, -self.height/2 - 20)
        scene.pop_matrix()

    def set_thrust(self, active):
        self.is_thrusting = active

    def rotate(self, direction): # -1 for left, 1 for right
        self.angular_velocity = direction * ROTATION_SPEED

    def stop_rotation(self):
        self.angular_velocity = 0

# --- Lunar Surface Generation (Simplified) ---
def generate_lunar_surface(width, height, num_points=100, num_pads=3, offset=None):
    surface_points = []
    # Simple random walk for terrain
    current_y = height / 4
    x_step = width / num_points
    for i in range(num_points + 1):
        x = i * x_step
        surface_points.append((x, current_y))
        current_y += random.uniform(-50, 50) # Random elevation change
        if current_y < 0: current_y = 0
        if current_y > height / 2: current_y = height / 2

    # Place landing pads
    landing_pads = []
    for _ in range(num_pads):
        # Find a relatively flat section
        start_index = random.randint(10, num_points - 20)
        end_index = start_index + random.randint(5, 10) # Pad length
        if end_index >= num_points: end_index = num_points -1

        # Flatten the section
        avg_y = sum(surface_points[i][1] for i in range(start_index, end_index + 1)) / (end_index - start_index + 1)
        for i in range(start_index, end_index + 1):
            surface_points[i] = (surface_points[i][0], avg_y)
        landing_pads.append({
            'x_start': surface_points[start_index][0],
            'x_end': surface_points[end_index][0],
            'y_level': avg_y
        })
    return surface_points, landing_pads

# --- Game Scene (Skeleton for Pythonista) ---
class LunarLanderGame(scene.Scene):
    def setup(self):
        self.background_color = (0, 0, 0) # Black space
        self.lander = Lander(self.size.w / 2, self.size.h * 0.75)
        self.lunar_surface_points, self.landing_pads = generate_lunar_surface(self.size.w, self.size.h)
        self.game_over = False
        self.game_message = ""
        self.setup_controls()
        
    def scroll(self, direction):
        pass
        
    def update(self):
        if self.game_over:
            return

        self.lander.update(self.dt)
        if self.lander.x_min < 0:
          self.scroll(-1)
        if self.lander.x_max > self.size.w:
          self.scroll(1)
        # Basic collision detection with terrain (needs refinement for poly collision)
        # Iterate through surface points and check if lander's bottom is below the line segment
        for i in range(len(self.lunar_surface_points) - 1):
            p1 = self.lunar_surface_points[i]
            p2 = self.lunar_surface_points[i+1]

            # Simplified check: if lander's x is between p1.x and p2.x, and lander.y is below
            # the line connecting p1 and p2. This is a very rough check.
            if p1[0] <= self.lander.x <= p2[0]:
                # Linear interpolation for y on the line segment
                terrain_y = p1[1] + (p2[1] - p1[1]) * ((self.lander.x - p1[0]) / (p2[0] - p1[0]))
                if self.lander.y - self.lander.height / 2 <= terrain_y:
                    self.handle_landing(terrain_y)
                    break # Collision detected
    
            
    def draw(self):
        scene.background(*self.background_color[:3])

        # Draw lunar surface
        scene.fill(0.2, 0.2, 0.2) # Dark grey for surface
        scene.stroke(0.5, 0.5, 0.5)
        scene.stroke_weight(2)
        draw_path(self.lunar_surface_points)
  
        
        scene.stroke(0.5, 0.5, 0.5)        

        # Highlight landing pads
        scene.fill(0, 0.5, 0) # Green for pads
        for pad in self.landing_pads:
            scene.rect(pad['x_start'], pad['y_level'], pad['x_end'] - pad['x_start'], 5) # Draw a small rectangle for the pad

        self.lander.draw()

        # Draw UI
        scene.text(f"Fuel: {self.lander.fuel}", font_size=20, x=100, y=self.size.h - 30)
        scene.text(f"Speed: {math.sqrt(self.lander.vx**2 + self.lander.vy**2):.1f}", font_size=20, x=100, y=self.size.h - 60)
        scene.text(f"Angle: {self.lander.angle:.1f}Â°", font_size=20, x=100, y=self.size.h - 90)

        if self.game_over:
            scene.tint(1, 1, 0)
            scene.text(self.game_message, font_size=50, x=self.size.w / 2, y=self.size.h / 2, alignment=5)
        scene.fill(0,1,0,.5)
        self.draw_controls()
   
    def setup_controls(self):
      
        button_size = 100
        padding = 20

        # Left/Right for rotation
        self.left_button_rect = scene.Rect(padding, padding + button_size, button_size, button_size) # x, y, w, h
        self.right_button_rect = scene.Rect(self.size.w - padding - button_size, padding + button_size, button_size, button_size)
        # Up/Down for movement
        self.forward_button_rect = scene.Rect(self.size.w / 2 - button_size / 2, padding + button_size, button_size, button_size)
     
    def text(self, txt, font= ('HelveticaNeue-Bold', 30), x=0, y=0, color='COLOR_WHITE', alignment=5):
        # wraps scene_drawing.text to provide color and alignment
        scene.tint(color)
        scene.text(txt, font_name=font[0], font_size=font[1], x=x, y=y, alignment=alignment)
           
    def draw_controls(self):
      
        scene.rect(*self.left_button_rect)
        scene.rect(*self.right_button_rect)
        scene.rect(*self.forward_button_rect)
        
        # Draw icons/text on buttons
        color=(1, 1, 1, 0.8) # White, semi-transparent
        btn_font = ('HelveticaNeue-Bold', 30)
        btn_center_offset = 50 # Half button size

        self.text("<<", font=btn_font,
                  x=self.left_button_rect[0] + btn_center_offset,
                  y=self.left_button_rect[1] + btn_center_offset,
                  color=color)
        self.text(">>", font=btn_font, 
                  x=self.right_button_rect[0] + btn_center_offset, 
                  y=self.right_button_rect[1] + btn_center_offset, 
                  color=color)
        self.text("^^", font=btn_font, 
                  x=self.forward_button_rect[0] + btn_center_offset, 
                  y=self.forward_button_rect[1] + btn_center_offset, 
                  color=color)
        
    def touch_began(self, touch):
        if self.left_button_rect.contains_point(touch.location):
            self.left_pressed = True
            self.lander.rotate(1)
        elif self.right_button_rect.contains_point(touch.location):
            self.right_pressed = True
            self.lander.rotate(-1)
        if self.forward_button_rect.contains_point(touch.location):
            self.forward_pressed = True
            self.lander.set_thrust(True)


    def touch_ended(self, touch):
        self.lander.set_thrust(False)
        self.lander.stop_rotation()

    def handle_landing(self, terrain_y):
        self.game_over = True
        landing_speed = math.sqrt(self.lander.vx**2 + self.lander.vy**2)
        landing_angle = abs(self.lander.angle - 90) # Difference from straight up

        on_pad = False
        for pad in self.landing_pads:
            if pad['x_start'] <= self.lander.x <= pad['x_end'] and abs(self.lander.y - self.lander.height/2 - pad['y_level']) < 5:
                on_pad = True
                break

        if on_pad and landing_speed <= LANDING_SPEED_TOLERANCE and landing_angle <= LANDING_ANGLE_TOLERANCE:
            self.game_message = "SUCCESSFUL LANDING!"
            self.lander.vy = 0 # Stop movement
            self.lander.vx = 0
        else:
            self.game_message = "CRASH!"
            # You might add explosion effects or different messages based on crash reason
            self.lander.vy = 0
            self.lander.vx = 0

# To run this in Pythonista:
if __name__ == '__main__':
   scene.run(LunarLanderGame())

"""
Next Steps for Pythonista
 * Save the Code: Save the code above as a Python file (e.g., lunar_lander.py) in Pythonista.
 * Run: Tap the "Play" button in Pythonista to run it.
 * Refine Graphics: Use scene.fill(), scene.stroke(), scene.rect(), scene.triangle(), scene.line() to draw more detailed shapes for the lander, its thrusters, and the terrain. Consider using images if you have them.
 * Complex Terrain: The generate_lunar_surface is very basic. For more realistic terrain, look into algorithms like Perlin noise or midpoint displacement.
 * Accurate Collision Detection: The current collision detection is rudimentary. For a good game, you'll need more precise polygon-to-line segment collision detection.
 * User Interface: Add on-screen controls (buttons) for left/right rotation and thrust, as touch alone can be imprecise. Pythonista's scene module supports touch events, so you can map areas of the screen to controls.
 * Sound Effects: Pythonista allows playing sound files, which would greatly enhance the game experience.
 * Game States: Implement proper game states (e.g., START_SCREEN, PLAYING, GAME_OVER, PAUSED) to manage the flow of the game.
 * Camera/Scrolling: If your lunar surface is wider than the screen, you'll need to implement camera scrolling that follows the lander.
This should give you a solid foundation to start building your Lunar Lander game in Pythonista!
"""
